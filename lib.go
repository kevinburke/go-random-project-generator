// Package random_project_generator generates random project names.
//
// Random names are generated by selecting a random adjective from a list of
// 1300 adjectives, and a random noun from a list of 870 nouns, giving you over
// a million possible combinations.
package random_project_generator

import (
	"fmt"
	"math/rand"
	"strconv"
	"strings"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

// Generate finds a random adjective and a random noun and joins them with
// a hyphen.
func Generate() string {
	adjective := Adjectives[rand.Intn(len(Adjectives))]
	noun := Nouns[rand.Intn(len(Nouns))]
	return adjective + "-" + noun
}

func tothe(power int) int {
	sum := 1
	for i := 0; i < power; i++ {
		sum = 10 * sum
	}
	return sum
}

// GenerateNumber returns a string with an adjective, a noun, and a number with
// d digits, joined together by hyphens. Each additional digit adds a factor of
// 9 to the number of possible results that can be generated, so 4 digits will
// yield roughly 7420491000 different possibilities.
func GenerateNumber(d int) string {
	if d <= 0 {
		panic(fmt.Sprintf("random_project_generator: invalid non positive length %d", d))
	}
	maxval := tothe(d) - 1
	minval := tothe(d - 1)
	return Generate() + "-" + strconv.Itoa(rand.Intn(maxval-minval)+minval)
}

// Valid returns true if s could have been generated by this library.
func Valid(s string) bool {
	groups := strings.Split(s, "-")
	if len(groups) == 1 || len(groups) > 3 {
		return false
	}
	adjectiveMatch := false
	// could prolly turn this into a map, but doesn't work if users can
	// redefine the list, also I don't think this is too slow - 6k ns/op to
	// search the entire list, but how many times are you doing it.
	for _, a := range Adjectives {
		if groups[0] == a {
			adjectiveMatch = true
			break
		}
	}
	if !adjectiveMatch {
		return false
	}
	nounMatch := false
	for _, n := range Nouns {
		if groups[1] == n {
			nounMatch = true
			break
		}
	}
	if !nounMatch {
		return false
	}
	if len(groups) == 3 {
		i, err := strconv.Atoi(groups[2])
		return err == nil && i > 0
	} else {
		return true
	}
}
